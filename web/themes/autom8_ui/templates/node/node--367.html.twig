<div class="w-full overflow-hidden rounded-lg shadow-xs">


<div class="w-full overflow-x-auto">


<div x-data="installationsTable()" x-init="fetchData">


	<p x-show="loading">Loading data...</p>

	<p x-show="error" style="color: red;">Error:
		<span x-text="error"></span>
	</p>

	<table x-show="installations.length > 0 && !loading">
		<thead>
			<tr class="text-xs font-semibold tracking-wide text-left text-gray-500 uppercase border-b dark:border-gray-700 bg-gray-50 dark:text-gray-400 dark:bg-gray-800">
				<th class="px-4 py-3">Title</th>
				<th class="px-4 py-3">Type</th>
				<th class="px-4 py-3">Host</th>
			</tr>
		</thead>
		<tbody>
			<template x-for="installation in installations" :key="installation.id">
				<tr>
					<td class="px-4 py-3 text-sm" x-text="installation.title"></td>
					<td class="px-4 py-3 text-sm">

						<div class="flex items-center ">
							<img class="w-10 h-auto" src="{{ theme_path }}/images/n8n.svg" :alt="installation.field_type"/>

							<span x-text="installation.field_type"></span>
						</div>


					</td>
					<td class="px-4 py-3 text-sm">

						<a class="text-sm font-medium text-purple-600 dark:text-purple-400 hover:underline" target="_blank" :href="installation.field_host" x-text="installation.field_host"></a>

					</td>
				</tr>
			</template>
		</tbody>
	</table>

</div>
</div>
</div>

<script>
	// Helper function to decode HTML entities using the browser's DOM
function decodeHtml(html) { // Create a temporary textarea element
const txt = document.createElement("textarea");
// Set the encoded string as the innerHTML. The browser automatically decodes entities.
txt.innerHTML = html;
// Return the decoded text value
return txt.value;
}

function installationsTable() {
return {
installations: [], loading: true, error: null,

// Function to fetch the data
async fetchData() {
try {
const response = await fetch('/rest/installations');

if (! response.ok) {
throw new Error(`HTTP error! status: ${
response.status
}`);
}

const data = await response.json();

// 1. Map over the fetched data to decode the 'title' property
const decodedData = data.map(installation => { // Create a new object to avoid modifying the original data directly (good practice)
return {
...installation,
// Apply the decoding function to the title
title: decodeHtml(installation.title)
};
});

// 2. Store the decoded data
this.installations = decodedData;

} catch (e) {
console.error("Fetch error:", e);
this.error = e.message;
} finally {
this.loading = false;
}
}
}
}
</script>


{# workflows  #}


<div x-data="n8nDashboard()" x-init="fetchData" x-cloak>


	<div x-show="isLoading" class="card">
		<p>Loading workflows and logs...</p>
	</div>

	<div x-show="error" class="card error">
		<p>Error:
			<span x-text="error"></span>
		</p>
		<p>Double-check your **Base URL** and **API Key**.</p>
	</div>

	<template x-if="!isLoading && !error">
		<div>
			<div class="card">
				<h2>üìã Workflows (<span x-text="workflows.length"></span>)</h2>
				<template x-for="workflow in workflows" :key="workflow.id">
					<div class="workflow-item">
						<strong x-text="workflow.name"></strong>
						-
						<span :style="{ color: workflow.active ? 'green' : 'gray' }" x-text="workflow.active ? 'Active' : 'Inactive'"></span>
						<small>(ID:
							<span x-text="workflow.id"></span>)</small>
					</div>
				</template>
				<p x-show="workflows.length === 0">No workflows found.</p>
			</div>

			<div class="card">
				<h2>‚è≥ Recent Execution Logs (<span x-text="executions.length"></span>)</h2>
				<template x-for="execution in executions" :key="execution.id">
					<div class="log-item">
						<strong x-text="execution.workflow.name"></strong>
						<span :style="{ color: execution.status === 'success' ? 'green' : 'red' }">
							(<span x-text="execution.status"></span>)
						</span>
						on
						<span x-text="new Date(execution.startedAt).toLocaleString()"></span>
					</div>
				</template>
				<p x-show="executions.length === 0">No recent logs found.</p>
			</div>
		</div>
	</template>
</div></div><script>
function n8nDashboard() {
return {
// Configuration
baseUrl: 'https://n8n.digitaldecibels.com', // Replace with your default URL
apiKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiMTRkODNjZS1lZTViLTRhYTktYWFiMi03MmJhZTExZmE3OWUiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzYzNDAxMDA3fQ.LouJnqhRZQfDKcEEc6K_NzpGzt8jP-fbaqEnTnY9VnQ',
// NEVER expose this in production code

// State
workflows: [],
executions: [],
isLoading: false,
error: '',

// Fetch function
async fetchData() {
if (!this.baseUrl || !this.apiKey) {
this.error = 'Please enter both the Base URL and the API Key.';
return;
}

this.isLoading = true;
this.error = '';
this.workflows = [];
this.executions = [];

const headers = {
'Accept': '*/*',
'X-N8N-API-KEY': this.apiKey
};

// --- 1. Fetch Workflows ---
const workflowUrl = `${
this.baseUrl.replace(/\/$/, "")
}/api/v1/workflows`;


try {
const workflowResponse = await fetch(workflowUrl, {headers});


if (! workflowResponse.ok) {
throw new Error(`HTTP error fetching workflows! Status: ${
workflowResponse.status
}`);
}
const data = await workflowResponse.json();
this.workflows = data.data;
} catch (e) {
this.error = `Failed to fetch workflows: ${
e.message
}`;
this.isLoading = false;
return;
}

}
}
}</script>
